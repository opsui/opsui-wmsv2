# ðŸ§  CLINE RULESET

**VERSION**: 4.0.0-OPTIMIZED
**LAST UPDATED**: 2025-02-06
**STATUS**: ENHANCED & STABLE

---

## ðŸŽ¯ CORE PRINCIPLES

### 1. FUNDAMENTAL GUIDELINES

**Quality Standards:**

- Readability over cleverness
- Explicit error handling
- Type safety with TypeScript
- Test coverage for business logic
- Security-first mindset

**Workflow:**

- Read relevant files before editing
- Consider edge cases
- Handle errors properly
- Follow existing patterns
- Update tests when changing code

**Communication:**

- Be direct and concise
- Explain reasoning when complex
- Ask when uncertain
- Proactively identify risks

---

## ðŸ’» CODE QUALITY

### 2. CODE STANDARDS

**Readability:**

```typescript
// âœ… GOOD - Self-documenting
const filterByIdIntersection = <T extends { id: string }>(
  items: T[],
  allowedIds: string[]
): T[] => items.filter(item => allowedIds.includes(item.id));

// âŒ BAD - Unclear
const d = (a, b) => a.filter(x => b.includes(x.id));
```

**Error Handling:**

```typescript
// âœ… GOOD - Explicit error handling
async function getUser(id: string): Promise<Result<User>> {
  try {
    const user = await db.findUser(id);
    if (!user) {
      return {
        success: false,
        error: { code: 'USER_NOT_FOUND', message: `No user with id: ${id}` },
      };
    }
    return { success: true, data: user };
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'DATABASE_ERROR',
        message: 'Failed to retrieve user',
        cause: error,
      },
    };
  }
}
```

**Type Safety:**

```typescript
// âœ… GOOD - Type guards
function isValidUser(data: unknown): data is User {
  return (
    typeof data === 'object' && data !== null && 'id' in data && 'email' in data
  );
}
```

**Naming Conventions:**

- Variables: `camelCase` (userProfile)
- Constants: `SCREAMING_SNAKE_CASE` (MAX_RETRY_ATTEMPTS)
- Types: `PascalCase` (UserProfile)
- Functions: `camelCase`, verb-first (getUserById)
- Files: `kebab-case` (user-service.ts)

---

## ðŸ—ï¸ ARCHITECTURE

### 3. PROJECT STRUCTURE

**Warehouse Management System:**

```
packages/backend/src/
  routes/       - HTTP endpoints
  services/     - Business logic
  repositories/ - Data access
  middleware/   - Express middleware
  types/        - TypeScript types

packages/frontend/src/
  components/   - React components
  pages/        - Page components
  hooks/        - Custom hooks
  stores/       - Zustand stores
  api/          - API client
```

**Patterns in Use:**

- Backend: Routes â†’ Services â†’ Repositories
- Frontend: React Query for server state, Zustand for UI state
- Database: PostgreSQL with transactions
- Authentication: JWT tokens

---

## ðŸš€ WORKFLOWS

### 4. DEVELOPMENT PROTOCOLS

**Before Making Changes:**

1. Read the target file completely
2. Read 2-3 related files for context
3. Search for similar patterns
4. Plan the complete change
5. Consider what tests need updating

**Response Structure:**

```
1. Analysis (what I found)
2. Recommendation (what to do, why)
3. Implementation (the solution)
4. Testing (how to verify)
```

**Testing Strategy:**

- Unit tests for functions and utilities
- Integration tests for services
- E2E tests for critical user flows
- Critical paths: 100% coverage

---

## ðŸ›¡ï¸ SECURITY

### 5. SECURITY CHECKLIST

For EVERY change:

- [ ] Input validation
- [ ] Authentication/authorization
- [ ] Parameterized queries (SQL injection prevention)
- [ ] XSS prevention
- [ ] CSRF protection
- [ ] Rate limiting consideration
- [ ] Error messages don't leak info
- [ ] Secrets properly managed

---

## ðŸ“Š PERFORMANCE

### 6. OPTIMIZATION GUIDELINES

**Before Optimizing:**

1. Measure first (profile)
2. Identify actual bottleneck
3. Set baseline metrics

**Common Issues:**

- N+1 queries â†’ Use eager loading
- Missing indexes â†’ Add database indexes
- Sequential async â†’ Use Promise.all()
- Unnecessary re-renders â†’ Use React.memo, useCallback

---

## ðŸ”„ REFACTORING

### 7. REFACTORING RULES

**When to Refactor:**

- Duplicated code (appears 3+ times)
- Long methods (>50 lines)
- Complex conditionals (>3 conditions)
- Large classes (>300 lines)

**Steps:**

1. Write tests covering behavior
2. Make smallest improvement
3. Run tests
4. Commit with descriptive message

---

## ðŸ“– DOCUMENTATION

### 8. DOCUMENTATION STANDARDS

**Code Should Be Self-Documenting:**

```typescript
// âœ… GOOD - Clear intent
if (user.hasAdminPrivileges && user.canModifyResources) {

// âŒ BAD - Needs comment
if (user.role === 1 && user.perm > 5) {
```

**When to Comment:**

- Complex business rules
- Workarounds for bugs
- Performance considerations
- Non-obvious optimizations
- Security implications

---

## ðŸŽ¯ PROJECT CONTEXT

### 9. WAREHOUSE MANAGEMENT SYSTEM

**Domain Knowledge:**

- Fulfillment system for warehouse operations
- Order lifecycle: Created â†’ Queued â†’ Claimed â†’ Picking â†’ Completed
- Inventory integrity is critical (never negative)
- Real-time updates needed
- Performance matters during peak hours

**Critical Paths:**

1. Order Creation â†’ Inventory Reservation (atomic)
2. Order Claiming (prevent double-claiming)
3. Picking Flow (fast barcode scanning)
4. Inventory Updates (transactional + audited)
5. Authentication (secure JWT tokens)

---

## ðŸ’¾ DATA OPERATIONS

### 10. DATABASE MANAGEMENT

**Use the data manager script:**

```bash
npm run db seed       # Add sample data (safe)
npm run db reset      # Complete reset (auto backup)
npm run db clean      # Remove all data (auto backup)
npm run db status     # Show database status
npm run db validate   # Check data integrity
npm run db backup     # Create backup
npm run db restore list     # List backups
npm run db restore <file>   # Restore from backup
```

**Sample Data:**

- 5 users (admin, pickers, packer, supervisor)
- 8 SKUs with inventory
- 10 sample orders

**Passwords work correctly:**

- admin@wms.local / admin123
- john.picker@wms.local / password123
- (all users use password123)

---

## ðŸš€ DEVELOPMENT SERVER

### 11. RUNNING THE PROJECT

**RECOMMENDED:**

```bash
npm run dev:restart  # Kill all + smart dev (best option)
```

**Options:**

```bash
npm run dev:restart  # Kill all + smart dev
npm run dev:smart    # Smart dev only
npm run dev          # Basic concurrent mode
npm run dev:safe     # Safe mode
```

**Why dev:restart:**

- Eliminates "port already in use" errors
- Prevents zombie processes
- Ensures clean state
- Activates connection draining

---

## ðŸŽ“ PATTERNS & BEST PRACTICES

### 12. COMMON PATTERNS

**What Works:**
âœ… Service layer transactions
âœ… Enum imports from shared
âœ… Result type for errors
âœ… Zod/Joi validation
âœ… React Query for server state
âœ… Soft delete (never hard delete user data)

**What Doesn't:**
âŒ Business logic in frontend
âŒ Skipping transactions
âŒ String literals for enums
âŒ Direct database access in controllers
âŒ Permanent user actions (everything reversible)

**Test Naming:**

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', async () => {
      /* ... */
    });
    it('should return error when email already exists', async () => {
      /* ... */
    });
  });
});
```

---

## ðŸ”§ DECISION MAKING

### 13. WHEN TO ACT VS ASK

**ACT IMMEDIATELY:**
âœ… Fixing obvious bugs
âœ… Adding missing tests
âœ… Improving code clarity
âœ… Adding error handling
âœ… Fixing security vulnerabilities
âœ… Optimizing slow code
âœ… Standardizing formatting

**ASK FIRST:**
â“ Multiple valid approaches with trade-offs
â“ Breaking changes to API
â“ Changing architectural patterns
â“ Adding new dependencies
â“ Performance optimizations needing benchmarking

---

## ðŸ“‹ QUALITY GATES

### 14. PRE-DELIVERY CHECKLIST

Before completing a task:

- [ ] Code compiles without errors
- [ ] All tests pass
- [ ] Error handling is comprehensive
- [ ] Edge cases are covered
- [ ] Security implications considered
- [ ] Performance implications considered
- [ ] Related files are updated
- [ ] No console.log statements left
- [ ] Code follows project patterns
- [ ] Types are properly defined
- [ ] Solution actually solves the problem

---

## ðŸŒŸ EXCELLENCE PRINCIPLES

### 15. CORE VALUES

**Your Goal:**
Every interaction should leave the codebase better than you found it.

**Key Quotes:**

> "Any fool can write code that a computer can understand. Good programmers write code that humans can understand." â€” Martin Fowler

> "The best code is no code. Every line of code is a liability. Make it work, make it right, make it gone." â€” Jeff Atwood

**Remember:**

- Build robust, maintainable systems
- Learn the domain deeply
- Teach best practices through example
- Protect the system from defects
- Optimize for performance and clarity
- Anticipate future needs

---

## ðŸš¨ EMERGENCY PROTOCOLS

### 16. WHEN THINGS GO WRONG

**If You Break the Build:**

1. STOP immediately
2. Assess what changed
3. Revert to last working state
4. Analyze what went wrong
5. Fix with smaller, safer changes
6. Test thoroughly

**If You Don't Understand:**

1. State the uncertainty clearly
2. Explain what you know and what you don't
3. Propose a plan to investigate
4. Ask if user wants you to proceed

**If Requirements Are Unclear:**

1. Ask clarifying questions
2. Propose assumptions
3. Proceed with verification

---

## ðŸ”š FINAL COMMANDMENTS

### 17. UNBREAKABLE RULES

1. **NEVER** guess - investigate if uncertain
2. **NEVER** skip reading files before editing
3. **NEVER** make assumptions without verifying
4. **NEVER** ship code without thinking through implications
5. **NEVER** compromise on quality for speed
6. **NEVER** leave the codebase worse than you found it
7. **NEVER** stop learning - every task teaches something

---

**END OF RULESET**

_These rules are designed to be effective and efficient._
_Follow them consistently and build excellent software._

ðŸš€ **GO FORTH AND CODE BRILLIANTLY** ðŸš€
