/**
 * Sales & CRM Service
 *
 * Business logic for customer management, leads, opportunities, and quotes
 */

import { salesRepository } from '../repositories/SalesRepository';
import { orderService } from './OrderService';
import {
  Customer,
  Lead,
  Opportunity,
  Quote,
  CustomerInteraction,
  CreateCustomerDTO,
  CreateLeadDTO,
  CreateOpportunityDTO,
  CreateQuoteDTO,
  CustomerStatus,
  LeadStatus,
  OpportunityStage,
  QuoteStatus,
  NotFoundError,
  // Phase 6: Sales Order Management
  SalesOrder,
  SalesOrderLine,
  Backorder,
  SalesCommission,
  SalesTerritory,
  SalesTerritoryCustomer,
  SalesTerritoryQuota,
  SalesOrderApproval,
  SalesOrderActivity,
  CreateSalesOrderDTO,
  CreateSalesOrderLineDTO,
  UpdateSalesOrderDTO,
  UpdateSalesOrderLineDTO,
  CreateBackorderDTO,
  CreateSalesTerritoryDTO,
  CreateTerritoryQuotaDTO,
  AssignTerritoryCustomerDTO,
  SalesOrderFilters,
  BackorderFilters,
  CommissionFilters,
  SalesOrderMetrics,
  TerritoryMetrics,
  SalesOrderStatus,
  BackorderStatus,
  CommissionStatus,
  ApprovalStatus,
} from '@opsui/shared';

export class SalesService {
  // ========================================================================
  // CUSTOMERS
  // ========================================================================

  async createCustomer(dto: CreateCustomerDTO, createdBy: string): Promise<Customer> {
    // Validate customer
    if (!dto.companyName || dto.companyName.trim() === '') {
      throw new Error('Company name is required');
    }

    if (!dto.billingAddress) {
      throw new Error('Billing address is required');
    }

    const customer = await salesRepository.createCustomer({
      ...dto,
      status: CustomerStatus.PROSPECT,
      createdBy,
    } as any); // customerNumber is generated by repository

    return customer;
  }

  async getCustomerById(customerId: string): Promise<Customer> {
    const customer = await salesRepository.findCustomerById(customerId);
    if (!customer) {
      throw new NotFoundError('Customer', customerId);
    }
    return customer;
  }

  async getAllCustomers(filters?: {
    status?: CustomerStatus;
    assignedTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ customers: Customer[]; total: number }> {
    return await salesRepository.findAllCustomers(filters);
  }

  async updateCustomer(
    customerId: string,
    dto: Partial<Customer>,
    userId: string
  ): Promise<Customer> {
    const customer = await salesRepository.findCustomerById(customerId);
    if (!customer) {
      throw new NotFoundError('Customer', customerId);
    }

    const updated = await salesRepository.updateCustomer(customerId, {
      ...dto,
      updatedBy: userId,
    });

    return updated as Customer;
  }

  // ========================================================================
  // LEADS
  // ========================================================================

  async createLead(dto: CreateLeadDTO, createdBy: string): Promise<Lead> {
    // Validate lead
    if (!dto.customerName || dto.customerName.trim() === '') {
      throw new Error('Customer name is required');
    }

    if (!dto.source || dto.source.trim() === '') {
      throw new Error('Lead source is required');
    }

    if (!dto.assignedTo) {
      throw new Error('Lead must be assigned to a user');
    }

    const lead = await salesRepository.createLead({
      ...dto,
      expectedCloseDate: dto.expectedCloseDate ? new Date(dto.expectedCloseDate) : undefined,
      status: LeadStatus.NEW,
      priority: 'MEDIUM' as any,
      createdBy,
    });

    return lead;
  }

  async getLeadById(leadId: string): Promise<Lead> {
    const lead = await salesRepository.findLeadById(leadId);
    if (!lead) {
      throw new NotFoundError('Lead', leadId);
    }
    return lead;
  }

  async getAllLeads(filters?: {
    status?: LeadStatus;
    assignedTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ leads: Lead[]; total: number }> {
    return await salesRepository.findAllLeads(filters);
  }

  async updateLead(leadId: string, dto: Partial<Lead>, userId: string): Promise<Lead> {
    const lead = await salesRepository.findLeadById(leadId);
    if (!lead) {
      throw new NotFoundError('Lead', leadId);
    }

    const updated = await salesRepository.updateLead(leadId, {
      ...dto,
      updatedBy: userId,
    });

    return updated as Lead;
  }

  async convertLeadToCustomer(leadId: string, userId: string): Promise<Customer> {
    const lead = await this.getLeadById(leadId);

    if (lead.status === LeadStatus.WON) {
      throw new Error('Lead already converted');
    }

    // Create customer from lead
    const customer = await salesRepository.createCustomer({
      companyName: lead.company || lead.customerName,
      contactName: lead.contactName,
      email: lead.email,
      phone: lead.phone,
      billingAddress: {
        street1: 'Address', // Would be provided in conversion
        city: 'City',
        state: 'State',
        postalCode: '0000',
        country: 'NZ',
      },
      status: CustomerStatus.PROSPECT,
      assignedTo: lead.assignedTo,
      createdBy: userId,
    } as any); // customerNumber is generated by repository

    // Update lead status
    await salesRepository.updateLead(leadId, {
      status: LeadStatus.WON,
      updatedBy: userId,
    });

    return customer;
  }

  // ========================================================================
  // OPPORTUNITIES
  // ========================================================================

  async createOpportunity(dto: CreateOpportunityDTO, createdBy: string): Promise<Opportunity> {
    // Validate opportunity
    if (!dto.name || dto.name.trim() === '') {
      throw new Error('Opportunity name is required');
    }

    if (!dto.amount || dto.amount <= 0) {
      throw new Error('Amount must be greater than 0');
    }

    if (!dto.expectedCloseDate) {
      throw new Error('Expected close date is required');
    }

    if (!dto.assignedTo) {
      throw new Error('Opportunity must be assigned to a user');
    }

    const opportunity = await salesRepository.createOpportunity({
      ...dto,
      expectedCloseDate: new Date(dto.expectedCloseDate),
      probability: dto.probability ?? 50,
      createdBy,
    });

    return opportunity;
  }

  async getOpportunityById(opportunityId: string): Promise<Opportunity> {
    const opportunity = await salesRepository.findOpportunityById(opportunityId);
    if (!opportunity) {
      throw new NotFoundError('Opportunity', opportunityId);
    }
    return opportunity;
  }

  async getAllOpportunities(filters?: {
    stage?: OpportunityStage;
    customerId?: string;
    assignedTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ opportunities: Opportunity[]; total: number }> {
    return await salesRepository.findAllOpportunities(filters);
  }

  async updateOpportunityStage(
    opportunityId: string,
    stage: OpportunityStage,
    userId: string
  ): Promise<Opportunity> {
    const opportunity = await salesRepository.findOpportunityById(opportunityId);
    if (!opportunity) {
      throw new NotFoundError('Opportunity', opportunityId);
    }

    // If closing as won or lost, record who and when
    const updates: Partial<Opportunity> = {
      stage,
      updatedBy: userId,
    };

    if (stage === OpportunityStage.CLOSED_WON || stage === OpportunityStage.CLOSED_LOST) {
      updates.closedAt = new Date();
      updates.closedBy = userId;
    }

    const updated = await salesRepository.updateOpportunity(opportunityId, updates);

    return updated as Opportunity;
  }

  // ========================================================================
  // QUOTES
  // ========================================================================

  async createQuote(dto: CreateQuoteDTO, createdBy: string): Promise<Quote> {
    // Validate quote
    if (!dto.customerId || dto.customerId.trim() === '') {
      throw new Error('Customer ID is required');
    }

    if (!dto.validUntil) {
      throw new Error('Valid until date is required');
    }

    if (!dto.lineItems || dto.lineItems.length === 0) {
      throw new Error('Quote must have at least one line item');
    }

    // Validate customer exists
    const customer = await salesRepository.findCustomerById(dto.customerId);
    if (!customer) {
      throw new NotFoundError('Customer', dto.customerId);
    }

    // Validate line items
    for (const item of dto.lineItems) {
      if (item.quantity <= 0) {
        throw new Error('Line item quantity must be greater than 0');
      }
      if (item.unitPrice < 0) {
        throw new Error('Line item unit price cannot be negative');
      }
    }

    const quote = await salesRepository.createQuote({
      ...dto,
      validUntil: new Date(dto.validUntil),
      status: QuoteStatus.DRAFT,
      createdBy,
    } as any);

    return quote;
  }

  async getQuoteById(quoteId: string): Promise<Quote> {
    const quote = await salesRepository.findQuoteById(quoteId);
    if (!quote) {
      throw new NotFoundError('Quote', quoteId);
    }
    return quote;
  }

  async getAllQuotes(filters?: {
    customerId?: string;
    status?: QuoteStatus;
    limit?: number;
    offset?: number;
  }): Promise<{ quotes: Quote[]; total: number }> {
    return await salesRepository.findAllQuotes(filters);
  }

  async sendQuote(quoteId: string, userId: string): Promise<Quote> {
    const quote = await this.getQuoteById(quoteId);

    if (quote.status !== QuoteStatus.DRAFT) {
      throw new Error('Only DRAFT quotes can be sent');
    }

    // In production, this would send an email
    // For now, just update the status

    await salesRepository.updateCustomer(quote.customerId, {
      lastContactDate: new Date(),
      updatedBy: userId,
    } as any);

    return quote; // Return original since update doesn't return full quote
  }

  async acceptQuote(quoteId: string, userId: string): Promise<{ quote: Quote; order?: any }> {
    const quote = await this.getQuoteById(quoteId);

    if (quote.status !== QuoteStatus.SENT) {
      throw new Error('Only SENT quotes can be accepted');
    }

    // Convert quote to order
    const order = await orderService.createOrder({
      customerId: quote.customerId,
      items: quote.lineItems.map(item => ({
        sku: item.sku,
        quantity: item.quantity,
      })),
      notes: quote.notes,
      createdBy: userId,
    } as any);

    // Update quote status and link to order
    await salesRepository.updateQuote(quoteId, {
      status: QuoteStatus.ACCEPTED,
      convertedToOrderId: order.orderId,
      updatedBy: userId,
    } as any);

    // Return updated quote and created order
    const updatedQuote = await this.getQuoteById(quoteId);
    return { quote: updatedQuote, order };
  }

  // ========================================================================
  // CUSTOMER INTERACTIONS
  // ========================================================================

  async logInteraction(
    dto: Omit<CustomerInteraction, 'interactionId' | 'createdAt'>
  ): Promise<CustomerInteraction> {
    // Validate interaction
    if (!dto.subject || dto.subject.trim() === '') {
      throw new Error('Subject is required');
    }

    if (!dto.notes || dto.notes.trim() === '') {
      throw new Error('Notes are required');
    }

    const interaction = await salesRepository.createInteraction({
      ...dto,
    });

    // Update customer last contact date if applicable
    if (interaction.customerId) {
      await salesRepository.updateCustomer(interaction.customerId, {
        lastContactDate: new Date(),
        updatedBy: dto.createdBy,
      } as any);
    }

    return interaction;
  }

  async getCustomerInteractions(
    customerId: string,
    limit: number = 50
  ): Promise<CustomerInteraction[]> {
    const customer = await salesRepository.findCustomerById(customerId);
    if (!customer) {
      throw new NotFoundError('Customer', customerId);
    }

    return await salesRepository.findInteractionsByCustomer(customerId, limit);
  }

  // ========================================================================
  // DASHBOARD
  // ========================================================================

  async getDashboard(): Promise<{
    totalCustomers: number;
    activeLeads: number;
    openOpportunities: number;
    pendingQuotes: number;
    totalPipeline: number;
  }> {
    const customersResult = await salesRepository.findAllCustomers({ limit: 1 });
    const leadsResult = await salesRepository.findAllLeads({
      status: LeadStatus.NEW,
      limit: 1,
    });
    const opportunitiesResult = await salesRepository.findAllOpportunities({
      stage: OpportunityStage.PROPOSAL,
      limit: 1,
    });
    const quotesResult = await salesRepository.findAllQuotes({
      status: QuoteStatus.SENT,
      limit: 1,
    });

    // Calculate total pipeline value from open opportunities
    const allOpportunitiesResult = await salesRepository.findAllOpportunities({
      limit: 1000,
    });
    const totalPipeline = allOpportunitiesResult.opportunities.reduce((sum, opp) => {
      if (
        opp.stage !== OpportunityStage.CLOSED_WON &&
        opp.stage !== OpportunityStage.CLOSED_LOST &&
        opp.amount
      ) {
        return sum + opp.amount;
      }
      return sum;
    }, 0);

    return {
      totalCustomers: customersResult.total,
      activeLeads: leadsResult.total,
      openOpportunities: opportunitiesResult.total,
      pendingQuotes: quotesResult.total,
      totalPipeline,
    };
  }

  // ========================================================================
  // SALES ORDERS (Phase 6)
  // ========================================================================

  async createSalesOrder(dto: CreateSalesOrderDTO, createdBy: string): Promise<SalesOrder> {
    // Validate sales order
    if (!dto.customerId || dto.customerId.trim() === '') {
      throw new Error('Customer ID is required');
    }

    if (!dto.lines || dto.lines.length === 0) {
      throw new Error('Sales order must have at least one line item');
    }

    // Validate customer exists
    const customer = await salesRepository.findCustomerById(dto.customerId);
    if (!customer) {
      throw new NotFoundError('Customer', dto.customerId);
    }

    // Validate line items
    for (const item of dto.lines) {
      if (item.quantity <= 0) {
        throw new Error('Line item quantity must be greater than 0');
      }
      if (item.unitPrice < 0) {
        throw new Error('Line item unit price cannot be negative');
      }
    }

    // Generate order number
    const orderNumber = await salesRepository.get_next_sales_order_number();

    // Create sales order
    const order = await salesRepository.createSalesOrder({
      ...dto,
      orderNumber,
      orderDate: new Date(),
      orderStatus: SalesOrderStatus.PENDING,
      paymentTerms: dto.paymentTerms || 'NET30',
      currency: dto.currency || 'NZD',
      exchangeRate: 1.0,
      subtotal: 0,
      discountAmount: 0,
      discountPercent: 0,
      taxAmount: 0,
      shippingAmount: 0,
      totalAmount: 0,
      commissionRate: dto.commissionRate || 0,
      commissionAmount: 0,
      commissionPaid: false,
      requiresApproval: false,
      approvalStatus: ApprovalStatus.PENDING,
      isBackorder: false,
      createdBy,
    } as any);

    // Create line items
    let lineNumber = 1;
    for (const lineDto of dto.lines) {
      await salesRepository.createSalesOrderLine({
        orderId: order.orderId,
        lineNumber: lineNumber++,
        sku: lineDto.sku,
        description: lineDto.description,
        quantity: lineDto.quantity,
        unitPrice: lineDto.unitPrice,
        discountPercent: lineDto.discountPercent || 0,
        discountAmount: 0,
        taxCode: lineDto.taxCode,
        taxRate: 0,
        taxAmount: 0,
        lineTotal: 0,
        quantityPicked: 0,
        quantityShipped: 0,
        quantityInvoiced: 0,
        quantityBackordered: 0,
        status: 'PENDING' as any,
        notes: lineDto.notes,
        createdAt: new Date(),
      } as any);
    }

    // Calculate and update order totals
    await salesRepository.update_sales_order_totals(order.orderId);

    // Calculate commission if sales person assigned
    if (dto.salesPersonId && dto.commissionRate && dto.commissionRate > 0) {
      await salesRepository.calculate_sales_commission(order.orderId);
    }

    // Get full order with lines
    return (await salesRepository.findSalesOrderById(order.orderId)) as any;
  }

  async getSalesOrderById(orderId: string): Promise<SalesOrder> {
    const order = await salesRepository.findSalesOrderById(orderId);
    if (!order) {
      throw new NotFoundError('Sales Order', orderId);
    }
    return order as any;
  }

  async getAllSalesOrders(
    filters?: SalesOrderFilters
  ): Promise<{ orders: SalesOrder[]; total: number }> {
    return await salesRepository.findAllSalesOrders(filters);
  }

  async updateSalesOrder(
    orderId: string,
    dto: UpdateSalesOrderDTO,
    userId: string
  ): Promise<SalesOrder> {
    const order = await this.getSalesOrderById(orderId);

    // Validate status transition if changing status
    if (dto.orderStatus && dto.orderStatus !== order.orderStatus) {
      // Define valid status transitions
      const validTransitions: Record<SalesOrderStatus, SalesOrderStatus[]> = {
        [SalesOrderStatus.DRAFT]: [SalesOrderStatus.PENDING, SalesOrderStatus.CANCELLED],
        [SalesOrderStatus.PENDING]: [SalesOrderStatus.CONFIRMED, SalesOrderStatus.CANCELLED],
        [SalesOrderStatus.CONFIRMED]: [SalesOrderStatus.PICKING, SalesOrderStatus.CANCELLED],
        [SalesOrderStatus.PICKING]: [SalesOrderStatus.PICKED, SalesOrderStatus.PARTIAL],
        [SalesOrderStatus.PICKED]: [SalesOrderStatus.SHIPPED],
        [SalesOrderStatus.PARTIAL]: [SalesOrderStatus.PICKING, SalesOrderStatus.SHIPPED],
        [SalesOrderStatus.SHIPPED]: [SalesOrderStatus.INVOICED],
        [SalesOrderStatus.INVOICED]: [SalesOrderStatus.CLOSED],
        [SalesOrderStatus.CLOSED]: [],
        [SalesOrderStatus.CANCELLED]: [],
      };

      const allowedStates = validTransitions[order.orderStatus] || [];
      if (!allowedStates.includes(dto.orderStatus)) {
        throw new Error(`Cannot transition from ${order.orderStatus} to ${dto.orderStatus}`);
      }
    }

    await salesRepository.updateSalesOrder(orderId, {
      ...dto,
      updatedBy: userId,
    } as any);

    return await this.getSalesOrderById(orderId);
  }

  async deleteSalesOrder(orderId: string): Promise<void> {
    const order = await this.getSalesOrderById(orderId);

    // Only allow deletion of draft or pending orders
    if (
      order.orderStatus !== SalesOrderStatus.DRAFT &&
      order.orderStatus !== SalesOrderStatus.PENDING
    ) {
      throw new Error('Can only delete draft or pending orders');
    }

    await salesRepository.deleteSalesOrder(orderId);
  }

  // ========================================================================
  // BACKORDERS (Phase 6)
  // ========================================================================

  async createBackorder(dto: CreateBackorderDTO, createdBy: string): Promise<Backorder> {
    // Validate backorder
    if (!dto.originalLineId || dto.originalLineId.trim() === '') {
      throw new Error('Original line ID is required');
    }

    if (dto.backorderQuantity <= 0) {
      throw new Error('Backorder quantity must be greater than 0');
    }

    // Create backorder using database function
    const backorderId = await salesRepository.create_backorder_from_line(
      dto.originalLineId,
      dto.backorderQuantity
    );

    const backorder = await salesRepository.findBackorderById(backorderId);
    return backorder as any;
  }

  async getBackorderById(backorderId: string): Promise<Backorder> {
    const backorder = await salesRepository.findBackorderById(backorderId);
    if (!backorder) {
      throw new NotFoundError('Backorder', backorderId);
    }
    return backorder as any;
  }

  async getAllBackorders(filters?: BackorderFilters): Promise<Backorder[]> {
    return await salesRepository.findAllBackorders(filters);
  }

  async fulfillBackorder(
    backorderId: string,
    quantity: number,
    userId: string
  ): Promise<Backorder> {
    const backorder = await this.getBackorderById(backorderId);

    if (backorder.status !== BackorderStatus.OPEN) {
      throw new Error('Can only fulfill open backorders');
    }

    if (quantity > backorder.quantityOutstanding) {
      throw new Error('Cannot fulfill more than outstanding quantity');
    }

    await salesRepository.fulfillBackorder(backorderId, quantity, userId);

    return await this.getBackorderById(backorderId);
  }

  // ========================================================================
  // COMMISSIONS (Phase 6)
  // ========================================================================

  async getAllCommissions(filters?: CommissionFilters): Promise<SalesCommission[]> {
    return await salesRepository.findAllCommissions(filters);
  }

  async getCommissionSummary(
    salesPersonId: string,
    year?: number
  ): Promise<{
    totalEarned: number;
    totalPaid: number;
    pendingPayment: number;
    transactionCount: number;
  }> {
    const commissions = await salesRepository.findAllCommissions({
      salesPersonId,
    });

    const filtered = year
      ? commissions.filter(c => c.commissionDate.getFullYear() === year)
      : commissions;

    return {
      totalEarned: filtered
        .filter(c => c.status !== CommissionStatus.VOIDED)
        .reduce((sum, c) => sum + c.commissionAmount, 0),
      totalPaid: filtered
        .filter(c => c.status === CommissionStatus.PAID)
        .reduce((sum, c) => sum + c.commissionAmount, 0),
      pendingPayment: filtered
        .filter(c => c.status === CommissionStatus.EARNED)
        .reduce((sum, c) => sum + c.commissionAmount, 0),
      transactionCount: filtered.length,
    };
  }

  async payCommissions(commissionIds: string[], paymentDate: Date, userId: string): Promise<void> {
    for (const commissionId of commissionIds) {
      await salesRepository.payCommission(commissionId, paymentDate, userId);
    }
  }

  // ========================================================================
  // TERRITORIES (Phase 6)
  // ========================================================================

  async createTerritory(dto: CreateSalesTerritoryDTO): Promise<SalesTerritory> {
    // Validate territory
    if (!dto.territoryCode || dto.territoryCode.trim() === '') {
      throw new Error('Territory code is required');
    }

    if (!dto.territoryName || dto.territoryName.trim() === '') {
      throw new Error('Territory name is required');
    }

    // Check if code already exists
    const existing = await salesRepository.findTerritoryByCode(dto.territoryCode);
    if (existing) {
      throw new Error('Territory code already exists');
    }

    return await salesRepository.createTerritory({
      ...dto,
      isActive: true,
      createdAt: new Date(),
    } as any);
  }

  async getAllTerritories(): Promise<SalesTerritory[]> {
    return await salesRepository.findAllTerritories();
  }

  async getTerritoryById(territoryId: string): Promise<SalesTerritory> {
    const territory = await salesRepository.findTerritoryById(territoryId);
    if (!territory) {
      throw new NotFoundError('Territory', territoryId);
    }
    return territory as any;
  }

  async getTerritoryMetrics(territoryId: string): Promise<TerritoryMetrics> {
    return await salesRepository.getTerritoryMetrics(territoryId);
  }

  async assignCustomerToTerritory(
    dto: AssignTerritoryCustomerDTO,
    userId: string
  ): Promise<SalesTerritoryCustomer> {
    // Validate territory exists
    const territory = await this.getTerritoryById(dto.territoryId);

    // Validate customer exists
    const customer = await salesRepository.findCustomerById(dto.customerId);
    if (!customer) {
      throw new NotFoundError('Customer', dto.customerId);
    }

    return await salesRepository.assignTerritoryCustomer({
      ...dto,
      assignedDate: new Date(),
      assignedBy: userId,
      createdAt: new Date(),
    } as any);
  }

  async createTerritoryQuota(dto: CreateTerritoryQuotaDTO): Promise<SalesTerritoryQuota> {
    // Validate territory exists
    await this.getTerritoryById(dto.territoryId);

    return await salesRepository.createTerritoryQuota({
      ...dto,
      actualAmount: 0,
      status: 'ACTIVE',
      createdAt: new Date(),
    } as any);
  }

  // ========================================================================
  // SALES ORDER METRICS (Phase 6)
  // ========================================================================

  async getSalesOrderMetrics(): Promise<SalesOrderMetrics> {
    return await salesRepository.getSalesOrderMetrics();
  }

  async getOrderActivity(orderId: string, limit: number = 50): Promise<SalesOrderActivity[]> {
    return await salesRepository.findOrderActivity(orderId, limit);
  }
}

// Singleton instance
export const salesService = new SalesService();
